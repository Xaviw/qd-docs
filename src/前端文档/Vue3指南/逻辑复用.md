---
sort: 5
---

# 逻辑复用

## 组合式函数

## 渲染函数

Vue 的单文件组件最终会编译为一个组件对象，所以在 JS、TS 文件中直接创建组件对象的方式也能创建组件。为了避免存在多个组件实例时对象值污染的问题，一般使用函数返回组件对象，所以也称为函数式组件

::: tip
这里的函数组件只是一种组件创建方式，不同于 Vue2 中的 `functional` 概念

Vue3 已经删除了 `functional` 选项，因为 2.x 中函数式组件带来的性能提升在 3.x 中已经可以忽略不计
:::

Vue3 为函数组件提供了类型辅助方法 `defineComponent` ，接受同 `script` 中相同的组件选项对象作为参数，且不会对参数做任何修改，只是用于提供类型提示

在 `3.3+` 的版本中，还支持另一种函数签名：以 `setup` 函数作为第一个参数，其他组件选项作为第二个参数。这种使用方式的好处是可以使用泛型定义 `props` 等的类型（但是仍需要在第二个参数选项中手动定义）

::: details defineComponent 定义类型

```tsx
import type { SlotsType } from 'vue'

// 组件类型定义方式一：不支持传入泛型
defineComponent<
  { options: Item[], data: Record<string, any>[] },
  { delRow: (index: number, data: Record<string, any>) => void },
  'delRow',
  SlotsType<{ title: { title: string } }>
>(
    () => {},
    {
      props: ['options', 'data'],
      emits: ['delRow'],
    }
    )

// 组件类型定义方式二：支持传入泛型
const Comp = defineComponent(
  <T extends Record<string, any>>(
    props: { options: Item[], data: T[] },
    { emit, slots }: SetupContext<{ delRow: (index: number, item: T) => void }>
  ) => {},
  // 目前仍然需要手动声明运行时的 props
  {
    props: ['options', 'data'],
    emits: ['delRow'],
    slots: Object as SlotsType<{
      title: { title: string }
    }>,
  }
)
```

:::

函数组件没有 `template`，如果需要渲染元素需要在 setup 方法中返回一个渲染函数，渲染函数内通过内置的 `h` 函数或者 `JXS/TSX` 创建元素。

`h` 函数也就是 `createVNode` 的别称，用来创建虚拟DOM

`JSX\TSX` 使用前需要先在 `vite` 中添加 `@vitejs/plugin-vue-jsx` 插件，之后对于 `.jsx/tsx` 文件或 `<script lang="jsx/tsx">` 中的 jsx 语法会被识别并编译为 `h` 函数

::: details JSX 使用说明

1. 必须要有一个根元素，可以是空元素`<></>`
2. 使用 `{}` 表示 JS 语法块
3. JSX 中使用 `ref` 值需要带 `.value`
4. 使用 JS 逻辑中的 `if`、`switch` 等代替 `v-if`、用元素数组代替 `v-for`

```tsx
// 三元表达式
const el = flag ? <AnyComp /> : <AnotherComp />

// 逻辑运算符
const el = flag && <AnyComp />
const el = flag || <AnyComp />

// if
if (flag)
  el = <AnyComp />
else
  el = <AnotherComp />

// switch
switch (flag) {
  case true:
    el = <AnyComp />
    break
  case false:
    el = <AnotherComp />
    break
}

// 元素数组会自动循环渲染
const els = [<AnyComp />, <AnotherComp />]
const comp = () => (<>{els}</>)

// 或者通过数组方法创建元素数组
const data = [1, 2, 3]
function el() {
  return (
    <>
      {
        data.map(item = <h1>{item}</h1>)
      }
    </>
  )
}
```

5. 使用 `onEvent` 格式的属性代替 `v-on`。如需带事件修饰符，只需要一个修饰符是可以按 `onEventModifier` 格式继续拼接在事件名后；多个修饰符可以使用 `withModifiers` 方法，第一个参数为绑定的方法，第二个参数为事件修饰符数组

```tsx
<Comp onClick={() => {}} /> // 等同于 @click

<Comp onClickCapture={() => {}} /> // 等同于 @click.capture

<Comp onClick={withModifiers(()=>{}, ['capture', 'once'])} /> // 等同于 @click.capture.once
```

6. 支持使用常用的指令：`v-text`、`v-html`、`v-show`、`v-model`（`v-model` 使用略有差别）

```tsx
const data = ref(1)

// 正常写法
<input v-model="value" /> // vue
<input v-model={data.value} /> // jsx

// 指定绑定值写法
<input v-model:modelValue="value" /> // vue
<input v-model={[data.value,'modelValue']} /> // jsx

// 修饰符写法
<input v-model:modelValue.trim="value" /> // vue
<input v-model={[data.value,'modelValue',['trim']]} /> // jsx
```

7. 组件的插槽会存储在 `setup` 方法第二个参数 `slots` 对象中，键名为插槽名，键值为插槽渲染函数，通过调用插槽渲染函数或判断后展示默认元素进行插槽渲染

```tsx
const Comp = defineComponent((props, { slots }) => {
  return () => (
    <>
      {slots.default?.() || <AnyComp />}
      {slots.title?.() || <AnotherComp />}
    </>
  )
})
```

8. 向组件传入插槽通过在组件标签中定义插槽对象实现，键名为插槽名，键值为渲染函数

```tsx
<Comp>
  {{
    default: () => <AnyComp />
    title: () => <AnotherComp />
  }}
</Comp>
```

:::

除了创建组件对象的方式之外，还可以通过创建返回一个返回 VNode 的函数来实现一个最简单的组件，例如：

```tsx
const comp = () => <h1>comp</h1>
// 等同于
const comp = () => h('h1', null, 'comp')
```

这种组件创建方式在 vue 文件的 `script` 块中也可以使用，可以方便的创建局部复用的小型组件，或配置式的构建某些布局，例如表格和表单

<IframeContainer title="JSX使用" src="https://play.vuejs.org/#eNqNVk9v3EQU/yojX+qFxZsQQMh4HUHJoZUoUZIDUtyDs57ddWvPWONxmsixBBKHglSEVC6oIAUJVCRugFQQhU/TDfRb8Oav7d3Nqj7s2jPvvfm993t/pnbeLwrvtMKO7wTlhKUFRyXmVYGymMzGkcPLs8gJI5LmBWUcHcUnGd6PZxhNGc1R5Hgju+RJ2fciEoyUJVCDD47zIos5hi+EgtbACBaCUWfXGcJpE0qm6cy7V1ICkGqhEzkTmhdphtnHBU8pKSPHR3JH7MVZRh/clmucVXho1idzPLm/Zv2eAOnDyz7DJWanOHLsHo/ZDHO1vXd4B5/Bu93MaVJlIL1h8wCXNKsERiX2QUUSgN2Rk2hvyVimZHZU7p1xTErjlAAqJBspHznAy80Nrrdwd7y3pF5EGoiijLFgAyKoeatRgqcpkeYowYQPET8vMDrMKC+PxFtjGIVDBYvMci4Fa3T78JOe0Agi+QarCE9zoyCVCMdsGk8wugXcAlhYQ5BNJzjzUckZuI0uhDFvL8M5IJGaCE1TnCVGQq8xTBLMdn3knsZZhX0Uk/MBGofX22kMDHwmsYPXcZXJ/673gbKvwSFEVXR9ifn4rj4eoSTmsY8O8ISyJFCHDgWI0MoAVcoUHJEd0AeANQXQZz4iVX6C2fB6G9KTU5om1kjkKCMiYeSCpSeoEU95BiGwLzoGDWpCIRy6SsUtGC3KIcjhPAWaS2ECNfIw6y9UWQnECkNojFwVUyHoybVdz7XHRM5/P/x8dfk8coSRiwsUzLdDtRSM4NUS39qd4zixZjUs8QScSajqC2ImoXo6+F4eF66bAgHLekp3HtZi05Op1EDnmPeMDQaS+6781eNHL/7+bkkSPlsUgzXo4RdqkhsHWk2FVtDZQh0iyfYq4mVf13urPvrcmEehkYkPWMRhx0rck6XSJql5GPRtRuDkJKy1pCogtKsTXH+rahogX1kXsUwUj62xph9O4VCy5BCsnVScU4IouZmlk/vjWlEuEs/t5LKKEfwJbptw8fDy5bc/BiOlvGRUYukFssuXoNkC1f6qMzvhM+s9K8tkyOx2V50UrXPFz1pk9IowrOtcWbUzWjUUwMBr3bBeNMuNxGzIdPHRMQQSUk6EMXJ08kTOXS2NZLC1mI632ZOY1EFmKJgxvXEwMDzdMA2knaXpbyb/K/Vet0eYynLtF+T5sfGrNjMjmO9ArzvPMNxGJjSjzGc4gTvJ4unjxdePoAfthEMzPSKHxGIa2Wh24mmHUORcffp08fAX22XFYw3MZIn09rpV46NtGDtvDvr1qlNOF+t4DEK7Kx2sLGKy5Ak6AQXw5d9vnsGlCfb7LQ0q9FWM6Hj89Ns6G526boOyOTyLP39/+c/n68MDCbQhNmrmbQrO68L+r5/pbLkOl2pu3QwRNQDpAbnpdlJEsC0RP7988ccXokYUfcASzNiZYOvdrrNW4er7rxZPnnQVtozCOy2K7niYVmQikhSa3Yey0PpzvuOznBDSW68soC9iJTlE24YMe0vpmd2vyjnUxjo7hdjqBFW5ceNGhwjjxx0Jx/0o5nOPxSShOdgM0Zb39qAjLV2VMtOM0mXx19D21tbAkqLfOqh7rdemqLrcm2Ie6yFUNtKTcd3609gggpB+U7cY3Vd7+aMvIuZKgpo1l6C1V4bVeXV99aiBAKNwpYLWDjrFVhNePftr8eXltbOsX4qd+Dd2YASqhWpJlSGN7trN/+ZyWZU=" />

## Inject、Provide

## 自定义指令
