---
sort: 5
---

# 逻辑复用

## 组合式函数

Vue3 改用 Proxy + 组合式 API 后，拥有了更细粒度的响应式系统，而且组合式 API 可以脱离组件使用，这使得 Vue3 可以封装**有状态的逻辑**，官方称为组合式函数（Composables）

类似于 React 中的 `Hooks` 概念，组合式函数允许我们像封装普通工具函数一样，封装带有视图状态的逻辑。具体使用中需要结合 Vue 的响应式原理，搞清楚哪些数据需要响应，以及数据的响应会对外部带来哪些影响等

按照规范组合式函数命名应该以 `use` 开头，通常会在项目中创建一个 `composables` 目录用于存放全局的组合式函数（与 `utils` 目录同级）

推荐查看[官方介绍](https://cn.vuejs.org/guide/reusability/composables.html#composables)

还可以从 [VueUse](https://vueuse.org/)（[中文文档](https://vueuse.pages.dev/functions.html)） 库中找到一些抽取组合式函数的灵感，熟悉库中已经提供的组合式函数也可以减少开发复杂度

类似的库还有 [VueHooksPlus](https://inhiblabcore.github.io/docs/hooks/guide/)，可以作为 VueUse 的补充，另外主要提供了 `useRequest` 函数，对请求做了较好的组合式封装

## 渲染函数

Vue 的单文件组件最终会编译为一个组件对象，所以在 JS、TS 文件中直接创建组件对象的方式也能创建组件。为了避免存在多个组件实例时对象值污染的问题，一般使用函数返回组件对象，所以也称为函数式组件

::: tip
这里的函数组件只是一种组件创建方式，不同于 Vue2 中的 `functional` 概念

Vue3 已经删除了 `functional` 选项，因为 2.x 中函数式组件带来的性能提升在 3.x 中已经可以忽略不计
:::

Vue3 为函数组件提供了类型辅助方法 `defineComponent` ，接受同 `script` 中相同的组件选项对象作为参数，且不会对参数做任何修改，只是用于提供类型提示

在 `3.3+` 的版本中，还支持另一种函数签名：以 `setup` 函数作为第一个参数，其他组件选项作为第二个参数。这种使用方式的好处是可以使用泛型定义 `props` 等的类型（但是仍需要在第二个参数选项中手动定义）

::: details defineComponent 定义类型

```tsx
import type { SlotsType } from 'vue'

// 组件类型定义方式一：不支持传入泛型
defineComponent<
  { options: Item[], data: Record<string, any>[] },
  { delRow: (index: number, data: Record<string, any>) => void },
  'delRow',
  SlotsType<{ title: { title: string } }>
>(
    () => {},
    {
      props: ['options', 'data'],
      emits: ['delRow'],
    }
    )

// 组件类型定义方式二：支持传入泛型
const Comp = defineComponent(
  <T extends Record<string, any>>(
    props: { options: Item[], data: T[] },
    { emit, slots }: SetupContext<{ delRow: (index: number, item: T) => void }>
  ) => {},
  // 目前仍然需要手动声明运行时的 props
  {
    props: ['options', 'data'],
    emits: ['delRow'],
    slots: Object as SlotsType<{
      title: { title: string }
    }>,
  }
)
```

:::

函数组件没有 `template`，可以实现一些无渲染组件。如果需要渲染元素需要在 setup 方法中返回一个渲染函数，渲染函数内通过内置的 `h` 函数或者 `JXS/TSX` 创建元素。

`h` 函数也就是 `createVNode` 的别称，用来创建虚拟DOM

`JSX\TSX` 使用前需要先在 `vite` 中添加 `@vitejs/plugin-vue-jsx` 插件，之后对于 `.jsx/tsx` 文件或 `<script lang="jsx/tsx">` 中的 jsx 语法会被识别并编译为 `h` 函数

::: details JSX 使用说明

1. 必须要有一个根元素，可以是空元素`<></>`
2. 使用 `{}` 表示 JS 语法块
3. JSX 中使用 `ref` 值需要带 `.value`
4. 使用 JS 逻辑中的 `if`、`switch` 等代替 `v-if`、用元素数组代替 `v-for`

```tsx
// 三元表达式
const el = () => flag ? <AnyComp /> : <AnotherComp />

// 逻辑运算符
const el = () => flag && <AnyComp />
const el = () => flag || <AnyComp />

// if
if (flag)
  el = () => <AnyComp />
else
  el = () => <AnotherComp />

// switch
switch (flag) {
  case true:
    el = () => <AnyComp />
    break
  case false:
    el = () => <AnotherComp />
    break
}

// 元素数组会自动循环渲染
const els = [<AnyComp />, <AnotherComp />]
const comp = () => (<>{els}</>)

// 或者通过数组方法创建元素数组
const data = [1, 2, 3]
function el() {
  return (
    <>
      {
        data.map(item = <h1>{item}</h1>)
      }
    </>
  )
}
```

5. 使用 `onEvent` 格式的属性代替 `v-on`。如需带事件修饰符，只需要一个修饰符时可以按 `onEventModifier` 格式继续拼接在事件名后；多个修饰符可以使用 `withModifiers` 方法，第一个参数为绑定的方法，第二个参数为事件修饰符数组

```tsx
<Comp onClick={() => {}} /> // 等同于 @click

<Comp onClickCapture={() => {}} /> // 等同于 @click.capture

<Comp onClick={withModifiers(()=>{}, ['capture', 'once'])} /> // 等同于 @click.capture.once
```

6. 支持使用常用的指令：`v-text`、`v-html`、`v-show`、`v-model`（`v-model` 使用略有差别）

```tsx
const data = ref(1)

// 正常写法
<input v-model="value" /> // vue
<input v-model={data.value} /> // jsx

// 指定绑定值写法
<input v-model:modelValue="value" /> // vue
<input v-model={[data.value,'modelValue']} /> // jsx

// 修饰符写法
<input v-model:modelValue.trim="value" /> // vue
<input v-model={[data.value,'modelValue',['trim']]} /> // jsx
```

7. 组件的插槽会存储在 `setup` 方法第二个参数 `slots` 对象中，键名为插槽名，键值为插槽渲染函数，通过调用插槽渲染函数或判断后展示默认元素进行插槽渲染

```tsx
const Comp = defineComponent((props, { slots }) => {
  return () => (
    <>
      {slots.default?.() || <AnyComp />}
      {slots.title?.() || <AnotherComp />}
    </>
  )
})
```

8. 向组件传入插槽通过在组件标签中定义插槽对象实现，键名为插槽名，键值为渲染函数

```tsx
<Comp>
  {{
    default: () => <AnyComp />
    title: () => <AnotherComp />
  }}
</Comp>
```

:::

除了创建组件对象的方式之外，还可以通过创建返回一个返回 VNode 的函数来实现一个最简单的组件，例如：

```tsx
const comp = () => <h1>comp</h1>
// 等同于
const comp = () => h('h1', null, 'comp')
```

这种组件创建方式在 vue 文件的 `script` 块中也可以使用，可以方便的创建局部复用的小型组件，或配置式的构建某些布局，例如表格和表单

::: warning
**在 TSX 中创建代码片段应该始终是渲染函数的形式，而不是只有元素本身，因为会丢失响应性**

<IframeContainer title="示例" src="https://play.vuejs.org/#eNqFkr2O00AQx19ltM05SmQrB9WxsQSnK6AABJTbGGeS891619qPYMmyxAtQQUWJkKjpEOJxLjwHs+s4cQFcYXln5vefmZ3Zjj1umnTnkV0wbktTNQ4sOt/kQlV1o42DS103sDG6hrM0C0bqbHsmFM8GnkgyHNaNLBySBcCjJqMzzyYBtmDOllptqm16Y7Wiml3ABSuJrySaF42rtLKCXUCMhFghpX73LPqc8bgY/eU1lrd/8d/YNvgEe2nQotmhYMeYK8wW3RC+ev0cWzofg7Vee0n0f4Kv0GrpQ48D9sSrNbU94WK3T+PkKrV9Y69ah8qOlwqNBrKPvGA0+DCqf1391O6D9GHUCdXTFMct0AAPS+pgjZtKxWxaoXILMLiBflhcLCTYI2FoV/RhG0UkKbyM/6k0SWawyqkLIgFoX5aQwhWwCjmT5WxMA5BlcPfr892PL/uv3/cfP+x/fvr9/ttUh3JJMn69zLuQIt0V0mPPM3KcsozoOaFD7XsEhl6oUQc24TESJtZRuX5inCezo8nfeue0Aq0uZVXerrpBfSoyn/f5fM6zgTvk5Fker9vPWP8H3acRag==" />

:::

<IframeContainer title="JSX 例子" src="https://play.vuejs.org/#eNqNVk9v3EQU/yojX+qFxZsQQMh4HUHJoZUoUZIDUtyDs57ddWvPWONxmsixBBKHglSEVC6oIAUJVCRugFQQhU/TDfRb8Oav7d3Nqj7s2jPvvfm993t/pnbeLwrvtMKO7wTlhKUFRyXmVYGymMzGkcPLs8gJI5LmBWUcHcUnGd6PZxhNGc1R5Hgju+RJ2fciEoyUJVCDD47zIos5hi+EgtbACBaCUWfXGcJpE0qm6cy7V1ICkGqhEzkTmhdphtnHBU8pKSPHR3JH7MVZRh/clmucVXho1idzPLm/Zv2eAOnDyz7DJWanOHLsHo/ZDHO1vXd4B5/Bu93MaVJlIL1h8wCXNKsERiX2QUUSgN2Rk2hvyVimZHZU7p1xTErjlAAqJBspHznAy80Nrrdwd7y3pF5EGoiijLFgAyKoeatRgqcpkeYowYQPET8vMDrMKC+PxFtjGIVDBYvMci4Fa3T78JOe0Agi+QarCE9zoyCVCMdsGk8wugXcAlhYQ5BNJzjzUckZuI0uhDFvL8M5IJGaCE1TnCVGQq8xTBLMdn3knsZZhX0Uk/MBGofX22kMDHwmsYPXcZXJ/673gbKvwSFEVXR9ifn4rj4eoSTmsY8O8ISyJFCHDgWI0MoAVcoUHJEd0AeANQXQZz4iVX6C2fB6G9KTU5om1kjkKCMiYeSCpSeoEU95BiGwLzoGDWpCIRy6SsUtGC3KIcjhPAWaS2ECNfIw6y9UWQnECkNojFwVUyHoybVdz7XHRM5/P/x8dfk8coSRiwsUzLdDtRSM4NUS39qd4zixZjUs8QScSajqC2ImoXo6+F4eF66bAgHLekp3HtZi05Op1EDnmPeMDQaS+6781eNHL/7+bkkSPlsUgzXo4RdqkhsHWk2FVtDZQh0iyfYq4mVf13urPvrcmEehkYkPWMRhx0rck6XSJql5GPRtRuDkJKy1pCogtKsTXH+rahogX1kXsUwUj62xph9O4VCy5BCsnVScU4IouZmlk/vjWlEuEs/t5LKKEfwJbptw8fDy5bc/BiOlvGRUYukFssuXoNkC1f6qMzvhM+s9K8tkyOx2V50UrXPFz1pk9IowrOtcWbUzWjUUwMBr3bBeNMuNxGzIdPHRMQQSUk6EMXJ08kTOXS2NZLC1mI632ZOY1EFmKJgxvXEwMDzdMA2knaXpbyb/K/Vet0eYynLtF+T5sfGrNjMjmO9ArzvPMNxGJjSjzGc4gTvJ4unjxdePoAfthEMzPSKHxGIa2Wh24mmHUORcffp08fAX22XFYw3MZIn09rpV46NtGDtvDvr1qlNOF+t4DEK7Kx2sLGKy5Ak6AQXw5d9vnsGlCfb7LQ0q9FWM6Hj89Ns6G526boOyOTyLP39/+c/n68MDCbQhNmrmbQrO68L+r5/pbLkOl2pu3QwRNQDpAbnpdlJEsC0RP7988ccXokYUfcASzNiZYOvdrrNW4er7rxZPnnQVtozCOy2K7niYVmQikhSa3Yey0PpzvuOznBDSW68soC9iJTlE24YMe0vpmd2vyjnUxjo7hdjqBFW5ceNGhwjjxx0Jx/0o5nOPxSShOdgM0Zb39qAjLV2VMtOM0mXx19D21tbAkqLfOqh7rdemqLrcm2Ie6yFUNtKTcd3609gggpB+U7cY3Vd7+aMvIuZKgpo1l6C1V4bVeXV99aiBAKNwpYLWDjrFVhNePftr8eXltbOsX4qd+Dd2YASqhWpJlSGN7trN/+ZyWZU=" />

## Inject、Provide

组件层级较深时，依靠 `props` 逐级传递会非常麻烦，Vue3 提供了 `provide` 和 `inject` 实现依赖注入解决这一问题

使用 `provide` 的组件会作为所有后代组件的**依赖提供者**，后代组件无论层级多深，都可以通过 inject 获取到祖先组件注入的依赖

**`provide` 与 `inject` 只能在 `setup` 中同步调用**

`provide` 接收两个参数:

1. **注入名**:可以是一个字符串或是一个 `Symbol`。后代组件会用注入名来查找期望注入的值
2. **提供的值**:值可以是任意类型，包括响应式的状态

推荐使用 `Symbol` 作为注入名，并配合 `InjectionKey` 接口为注入值标注类型：

```ts
import { inject, provide } from 'vue'
import type { InjectionKey } from 'vue'

const key = Symbol() as InjectionKey<string>

provide(key, 'foo') // 若提供的是非字符串值会导致错误

const foo = inject(key) // foo 的类型：string | undefined

// 使用字符串注入名时，也可以通过泛型定义接收的值类型
const foo = inject<string>('key') // 类型：string | undefined
const foo = inject<string>('key', 'foo') // 提供了默认值，类型：string
const foo = inject('key') as string // 强制指定类型为 string
```

`inject` 第一个参数为对应的注入名，后面还有两个可选参数

- 第二个参数为未获取到值时使用的默认值
- 第三个参数设置为 `true`，表示第二个参数是工厂函数，可以避免在用不到默认值的情况下进行不必要的计算或产生副作用

一个组件可以多次调用 `provide`、`inject`，使用不同的注入名进行区分。当注入的响应式值可能被修改时，官方建议是同时注入修改值的方法，这是为了将声明和更改内聚在一起，可以更清晰的知道值相关的所有逻辑，利于维护

## 自定义指令

Vue3 中自定义指令与 Vue2 有一些差别，查看[官方文档](https://cn.vuejs.org/guide/reusability/custom-directives.html)
