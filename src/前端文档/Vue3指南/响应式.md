---
sort: 4
---

# 响应式

## 响应式原理

Vue2 使用 `Object.defineProperty` 实现响应式，会在组件初始化时，递归的对 `data` 选项中每个属性进行劫持

当修改被劫持的属性时，Vue 能够监听到修改，会对传入的值继续进行劫持处理，并且通知视图更新。但如果是添加新属性或者删除属性时，Vue 无法监听到操作，当然也就无法实现响应式功能。

对于数组，如果元素是对象，Vue 同样会进行递归的劫持处理，但是对数组的下标并没有进行劫持。因为对数组进行例如 `unshift` 操作时，旧数据中所有元素的下标都会后移，导致每个下标属性的修改劫持都被触发，同时进行大量的视图更新操作，性能开销非常大

为了实现数组的响应式，Vue2 对修改数组的方法进行了重写，修改数组实际上是对数组所属的属性重新赋值。这样跳过了数组下标的劫持，对于数组中的对象元素已经处理过的也不会再次劫持，虽然损失了操作便捷性（不能通过下标修改），但是得到了性能提升

从 Vue2 的响应式原理中可以看出 `Object.defineProperty` 的缺点：

1. 初始化时需要进行递归遍历，性能开销大
2. 无法直接监听新增和删除操作
3. 数组无法通过下标操作

Vue3 改用 `Proxy` 实现响应式后，这些问题得到了解决。`Proxy` 是对象层面的代理，可以从更底层对对象进行监听，包括新增、删除、数组方法和数组下标修改等操作

另外 Vue3 中采用了惰性的对深层次对象进行响应式处理，只有访问到深层次的对象时才创建代理，性能得到了进一步提升

::: tip 为什么 Vue2 不惰性响应式处理？
因为 `Object.defineProperty` 是对属性进行处理，如果放在监听中惰性处理，每次访问对象时都需要对其中的全部属性进行劫持处理，相比于一次性递归处理，性能会更差

而 Vue3 中 `Proxy` 是代理对象整体，每次访问对象只需要处理一次，惰性处理的性能会更高
:::

## 响应式 API

Vue3 创建响应式数据主要通过两个 API：`ref` 和 `reactive`

`reactive` 接收对象类型的值作为参数（包括数组等），内部会通过 `Proxy` 对值进行代理，返回一个新的代理对象（**与源对象不相等**）。如果使用 ts，可以通过泛型约束值的类型

<IframeContainer title="reactive" src="https://play.vuejs.org/#eNp9UTtvwjAQ/isnL4CEEqF2QglSHwzt0FZtRy9uOIKpY1t+pEiR/3sdRwkMiM3+Hnff3XXkQeus9UjWpLCV4dqBRec1CCbrkhJnKdlQyRutjIMODLLK8RYhwN6oBmbRO6OSykpJ60AZXnP5zByDMqpbJjyuYQVhFOwGaixTTBrpmx80EDbzc43FWFgJzISq54O7LC/6LCDPYc+ERSqLfBghBo4fh40WzGH8ARSH1abrUvssdYQQijyCvWtSkmUcODbc8zo7WiXjVrreTUmlGs0FmnfteAxEyRoS03NMCPX3mjBnPC5HvDpg9XsFP9pTj1HyYdCiaZGSiXPM1OgGevv1hqf4nshG7byI6hvkJ8Zl+T7jIHv0chdjX+hS2pd0Ty7rb7s9OZR2HKoP2itD0lMSz/t0Y/Rz3LvsPvmoDCT8A62hyTA=" />

`ref` 接收任意类型的值作为参数，返回一个带有 `value` 属性的响应式对象，可以简单理解为（**实际上不是这样处理的**）:

```ts
function ref<T>(value: T) {
  return reactive({ value })
}
```

这样理解后，`ref` 就和 `reactive` 的使用方式一致了。但是在 `template` 中，Vue3 会自动对 `ref` 值进行解包，也就是不需要添加 `.value` 访问值了：

<IframeContainer title="ref" src="https://play.vuejs.org/#eNp9UslOwzAQ/ZWRLy1SlajAqUoqsfQAB0DA0ZeQTtIUx7a8lEqR/52J06YVQj0l85bxm7E7dqd1svPIFiyzpWm0A4vOaxCFrHPOnOVsyWXTamUcdGCwggCVUS1MyDbhkstSSUs2ZyCHyQaFUAQP4LpwxZxgsmUkaGS9nNL36mRTpqkb+Ug6knWwK4THBcwhnLe4PrQYeenbLzQQltOTf2yqBCZC1dPoTKID8jw/O+oK0hSqQljkMkuHuWlKKhy2WhQOqQLINvNl1x2GCCFLqf6DH/uPbJaOLdiM1keBqqZOtlZJ2nHX2zkrVasbgeZVu4YCc7aAyPRcQfv7eY6YMx5nR7zcYPn9D761+x7j7M2gRbNDzkbOFaZGN9Crjxfc0/9ItmrtBakvkO9Iy/R9xkF27+WaYp/pYtqn+Drocj/tau9Q2uNQfdBeGaKeM3oxDxdGP8W9SW6jj8vAwi/I4OKj" />

日常开发中可以通过一个简单的原则来决定使用哪个 API：

> 属性固定的对象使用 `reactive`，其他一律使用 `ref`

::: tip 为什么 `ref` 不通过 `reactive` 包裹实现基础类型值的响应式处理？
`ref` 对基础类型的值实际是通过 `getter` 和 `setter` 实现的响应式，大致源码为：

```ts
function ref<T>(value: T): { value: T } {
  return {
    _value: value,
    get value() {
      track()
      return this._value
    },
    set value(newValue) {
      this._value = newValue
      trigger()
    }
  }
}
```

**这样做最主要的目的是阻止 `delete refData.value` 操作**

因为 `reactive` 方法返回的代理对象是可以通过 `delete` 删除 `value` 的，而删除后再次通过 `.value` 赋值不会拥有响应性。通过 `getter` 定义 value 属性
:::
